#N canvas 1914 0 1920 956 12;
#X obj 583 608 *~;
#X obj 582 1413 dac~;
#X msg 26 162 \; pd dsp \$1;
#X obj 26 106 tgl 50 0 empty empty DSP_on_off 0 -10 0 12 #fcfcc4 #000000 #000000 0 1;
#X obj 583 537 osc~ 440;
#X text 327 1354 Send signal out to a DAC (Digital to Analogue Converter) to create audio signal output on your selected device, f 28;
#X text 119 104 Turn DSP on/off (Digital Signal Processing) - this basically makes the sound happen when it's on \, and doesn't make it happen when it's off, f 28;
#X text 355 610 Multiply signals together;
#X obj 1325 306 hsl 300 50 40 200 0 0 empty empty change_tempo 10 -10 0 12 #e0c4fc #000000 #000000 0 1;
#X text 17 249 WHAT DOES THIS PATCH DO? - Takes a given 'pulse rate' (tempo value) in BPM - Creates a pulsing sine tone to the given tempo HOW TO USE IT? - Make sure your audio device is set up correctly in Media > Audio Settings... - Turn DSP on - Press the big green button to start/stop playback - Click and drag the big purple slider to change the pulse rate value (in the range 40-200 BPM), f 39;
#X obj 789 132 tgl 75 0 empty empty start_or_stop_pulse 7 -10 0 12 #c4fcc4 #000000 #000000 0 1;
#X floatatom 1322 361 5 0 0 0 - - - 0;
#X floatatom 1354 434 5 0 0 0 - - - 0;
#X obj 1322 384 t b f;
#X obj 1354 410 expr floor($f1);
#X obj 789 328 metro 1 120 permin;
#X obj 1333 213 loadbang;
#X msg 1333 237 120;
#X text 1369 236 Default start-up tempo is 120BPM;
#X text 1470 410 Convert tempo to int value;
#X obj 789 362 bng 19 250 50 0 empty empty empty 0 -10 0 12 #fcfcfc #000000 #000000;
#X text 691 332 Create pulses to the given tempo (120BPM by default), f 11;
#X msg 967 243 0.5;
#X msg 1003 243 1;
#X text 1049 242 beat length;
#X floatatom 932 304 5 0 0 0 - - - 0;
#X obj 932 280 expr 1/$f1;
#X msg 932 243 2;
#X obj 805 279 r tempo;
#X obj 1354 457 s tempo;
#X obj 1003 218 loadbang;
#X text 980 566 Trigger ADSR envelope;
#X text 677 444 Toggle ADSR on;
#X text 863 444 Toggle ADSR off after 2ms delay;
#X msg 805 303 tempo \$1 permin;
#X msg 789 445 1;
#X msg 827 445 0;
#X obj 827 420 del 2;
#X obj 583 1375 *~;
#X obj 639 1165 tgl 75 0 empty empty turn_audio_on_off 5 -10 0 12 #c4fcc4 #000000 #000000 0 1;
#X obj 639 1120 r appOnOff;
#X obj 1322 71 r appHeartRate;
#N canvas -32 228 1920 997 adsr 0;
#X obj 129 120 inlet;
#X obj 438 160 inlet;
#X text 125 95 trigger;
#X obj 129 148 sel 0;
#X obj 190 273 f \$1;
#X obj 495 160 inlet;
#X obj 422 285 del \$2;
#X obj 595 456 line~;
#X obj 446 313 f \$4;
#X obj 545 160 inlet;
#X obj 600 160 inlet;
#X obj 656 160 inlet;
#X msg 129 179 stop;
#X obj 596 315 pack 0 \$5;
#X text 438 138 level;
#X obj 485 364 * \$1;
#X obj 595 486 outlet~;
#X text 57 135 if zero;
#X text 57 152 release;
#X text 36 169 and cancel;
#X text 71 186 decay;
#X text 667 307 on release ramp;
#X text 668 324 back to zero;
#X obj 446 338 * 0.01;
#X text 82 564 Objects such as "f" and "pack" can be given dollar sign arguments to initialize their contents from adsr's creation arguments. Inlets are supplied to change them on the fly.;
#X text 122 35 ADSR ENVELOPE;
#X text 491 138 attack;
#X text 546 138 decay;
#X text 593 138 sustain;
#X text 653 138 release;
#X text 229 80 attack;
#X obj 231 101 moses;
#X obj 218 131 t b b;
#X msg 152 299 0;
#X text 58 266 ATTACK:;
#X text 82 474 When you send this patch a positive trigger it schedules a line~ to do an attack and decay \, and if zero \, it starts the release ramp.;
#X text 596 564 Updated for Pd version 0.37;
#X text 279 98 test for negative trigger;
#X text 277 122 if so \, zero;
#X text 278 137 the output;
#X text 300 174 in any case;
#X text 442 122 peak;
#X text 303 158 ... do this;
#X text 82 526 Negative triggers cause the output to jump to zero and then attack (instead of attacking from the current location).;
#X text 343 20 Arguments: level \, attack time \, decay time \, sustain level \, release time. A \, D \, and R are in msec and S is in percent. This patch is used as an abstraction in various examples.;
#X obj 596 356 s line;
#X obj 485 419 s line;
#X obj 190 328 s line;
#X obj 595 419 r line;
#X text 309 374 multiply by peak level and pack with decay time, f 24;
#X text 292 281 on attack \, set a delay for sustain, f 17;
#X text 297 319 recall sustain value convert from percent, f 20;
#X text 57 288 optionally bash to zero, f 12;
#X text 21 326 then recall peak level and pack with attack time and send to line~, f 22;
#X text 387 420 send to line~;
#X text 645 356 send to line~;
#X text 649 412 get attack/decay/release lines, f 23;
#X text 644 456 generate envelope;
#X obj 263 164 b;
#X obj 190 298 pack f \$2;
#X obj 485 388 pack f \$3;
#X connect 0 0 3 0;
#X connect 1 0 4 1;
#X connect 1 0 15 1;
#X connect 3 0 12 0;
#X connect 3 0 13 0;
#X connect 3 1 31 0;
#X connect 4 0 59 0;
#X connect 5 0 6 1;
#X connect 5 0 59 1;
#X connect 6 0 8 0;
#X connect 7 0 16 0;
#X connect 8 0 23 0;
#X connect 9 0 60 1;
#X connect 10 0 8 1;
#X connect 11 0 13 1;
#X connect 12 0 6 0;
#X connect 13 0 45 0;
#X connect 15 0 60 0;
#X connect 23 0 15 0;
#X connect 31 0 32 0;
#X connect 31 1 58 0;
#X connect 32 0 58 0;
#X connect 32 1 33 0;
#X connect 33 0 47 0;
#X connect 48 0 7 0;
#X connect 58 0 4 0;
#X connect 58 0 6 0;
#X connect 59 0 47 0;
#X connect 60 0 46 0;
#X restore 789 568 pd adsr;
#X f 26;
#X obj 824 492 loadbang;
#X msg 860 544 10;
#X msg 896 544 100;
#X msg 824 544 1;
#X obj 26 3 loadbang;
#X msg 26 27 1;
#N canvas 0 28 1440 872 bound_values 0;
#X floatatom 34 168 5 0 0 0 - - - 0;
#X floatatom 34 275 5 0 0 0 - - - 0;
#X floatatom 34 322 5 0 0 0 - - - 0;
#X obj 34 345 outlet;
#X obj 34 191 expr if ($f1 >= $f2 \, $f2 \, $f1);
#X text 258 191 Only take values <= the upper bound value;
#X text 257 299 Only take values >= the lower bound value;
#X obj 34 112 inlet input_value;
#X obj 241 162 inlet upper_bound;
#X obj 241 271 inlet lower_bound;
#X obj 34 298 expr if ($f1 <= $f2 \, $f2 \, $f1);
#X text 813 55 Bounds the given input value to the specified interval range: [upper bound \, lower bound].;
#X text 806 102 Args: input_value (float) - the value of the particular input (eg \, heart rate) upper_bound (float) - the upper bound to restrict the input value by. If input_value > upper_bound \, returns the upper_bound. lower_bound (float) - the lower bound to restrict the input value by. If input_value < lower_bound \, returns the lower_bound.;
#X text 814 208 Returns: the bounded input value;
#X text 241 247 LOWER BOUND (MIDDLE INLET):;
#X text 241 138 UPPER BOUND (RIGHT INLET):;
#X text 34 88 INPUT VALUE (LEFT INLET):;
#X connect 0 0 4 0;
#X connect 1 0 10 0;
#X connect 2 0 3 0;
#X connect 4 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 4 1;
#X connect 9 0 10 1;
#X connect 10 0 2 0;
#X restore 1322 179 pd bound_values;
#X floatatom 1322 153 5 0 0 0 - - - 0;
#X floatatom 1322 263 5 0 0 0 - - - 0;
#X floatatom 1424 153 5 0 0 0 - - - 0;
#X msg 1424 129 200;
#X floatatom 1373 153 5 0 0 0 - - - 0;
#X msg 1373 129 40;
#X text 1495 1099 TODD HOWARD (TODO):;
#X text 1471 142 Bound the heart rate values in the interval [40 \, 200] BPM;
#X obj 1373 96 loadbang;
#X text 1304 48 HEART RATE INPUT:;
#X text 636 1099 TOGGLE ON/OFF INPUT:;
#X msg 932 544 100;
#N canvas -32 228 1920 997 adsr 0;
#X obj 129 120 inlet;
#X obj 438 160 inlet;
#X text 125 95 trigger;
#X obj 129 148 sel 0;
#X obj 190 273 f \$1;
#X obj 495 160 inlet;
#X obj 422 285 del \$2;
#X obj 595 456 line~;
#X obj 446 313 f \$4;
#X obj 545 160 inlet;
#X obj 600 160 inlet;
#X obj 656 160 inlet;
#X msg 129 179 stop;
#X obj 596 315 pack 0 \$5;
#X text 438 138 level;
#X obj 485 364 * \$1;
#X obj 595 486 outlet~;
#X text 57 135 if zero;
#X text 57 152 release;
#X text 36 169 and cancel;
#X text 71 186 decay;
#X text 667 307 on release ramp;
#X text 668 324 back to zero;
#X obj 446 338 * 0.01;
#X text 82 564 Objects such as "f" and "pack" can be given dollar sign arguments to initialize their contents from adsr's creation arguments. Inlets are supplied to change them on the fly.;
#X text 122 35 ADSR ENVELOPE;
#X text 491 138 attack;
#X text 546 138 decay;
#X text 593 138 sustain;
#X text 653 138 release;
#X text 229 80 attack;
#X obj 231 101 moses;
#X obj 218 131 t b b;
#X msg 152 299 0;
#X text 58 266 ATTACK:;
#X text 82 474 When you send this patch a positive trigger it schedules a line~ to do an attack and decay \, and if zero \, it starts the release ramp.;
#X text 596 564 Updated for Pd version 0.37;
#X text 279 98 test for negative trigger;
#X text 277 122 if so \, zero;
#X text 278 137 the output;
#X text 300 174 in any case;
#X text 442 122 peak;
#X text 303 158 ... do this;
#X text 82 526 Negative triggers cause the output to jump to zero and then attack (instead of attacking from the current location).;
#X text 343 20 Arguments: level \, attack time \, decay time \, sustain level \, release time. A \, D \, and R are in msec and S is in percent. This patch is used as an abstraction in various examples.;
#X obj 596 356 s line;
#X obj 485 419 s line;
#X obj 190 328 s line;
#X obj 595 419 r line;
#X text 309 374 multiply by peak level and pack with decay time, f 24;
#X text 292 281 on attack \, set a delay for sustain, f 17;
#X text 297 319 recall sustain value convert from percent, f 20;
#X text 57 288 optionally bash to zero, f 12;
#X text 21 326 then recall peak level and pack with attack time and send to line~, f 22;
#X text 387 420 send to line~;
#X text 645 356 send to line~;
#X text 649 412 get attack/decay/release lines, f 23;
#X text 644 456 generate envelope;
#X obj 263 164 b;
#X obj 190 298 pack f \$2;
#X obj 485 388 pack f \$3;
#X connect 0 0 3 0;
#X connect 1 0 4 1;
#X connect 1 0 15 1;
#X connect 3 0 12 0;
#X connect 3 0 13 0;
#X connect 3 1 31 0;
#X connect 4 0 59 0;
#X connect 5 0 6 1;
#X connect 5 0 59 1;
#X connect 6 0 8 0;
#X connect 7 0 16 0;
#X connect 8 0 23 0;
#X connect 9 0 60 1;
#X connect 10 0 8 1;
#X connect 11 0 13 1;
#X connect 12 0 6 0;
#X connect 13 0 45 0;
#X connect 15 0 60 0;
#X connect 23 0 15 0;
#X connect 31 0 32 0;
#X connect 31 1 58 0;
#X connect 32 0 58 0;
#X connect 32 1 33 0;
#X connect 33 0 47 0;
#X connect 48 0 7 0;
#X connect 58 0 4 0;
#X connect 58 0 6 0;
#X connect 59 0 47 0;
#X connect 60 0 46 0;
#X restore 639 1322 pd adsr;
#X f 26;
#X obj 674 1246 loadbang;
#X obj 789 58 r appOnOff;
#X text 786 34 TOGGLE ON/OFF INPUT:;
#X msg 746 1298 0;
#X msg 782 1298 0;
#X msg 710 1298 0;
#X obj 789 82 del 1 0 msec;
#X text 883 77 Can use this to add a slight delay to sync pulse start with volume toggle on (if required), f 53;
#X msg 818 1298 4;
#X text 1255 968 Have changed how on/off switch works - make immediate volume off;
#X text 853 1299 Trigger ADSR envelope that turns audio on instantly (0ms) and ramps audio signal from on to off (in 4ms), f 44;
#X obj 583 1068 *~;
#X obj 791 859 vsl 50 120 0 1 0 0 empty empty dynamic_control 0 -9 0 12 #feffc6 #000000 #000000 0 1;
#X floatatom 791 987 5 0 0 0 - - - 0;
#X obj 804 770 loadbang;
#N canvas 0 28 1440 872 bound_values 0;
#X floatatom 34 168 5 0 0 0 - - - 0;
#X floatatom 34 275 5 0 0 0 - - - 0;
#X floatatom 34 322 5 0 0 0 - - - 0;
#X obj 34 345 outlet;
#X obj 34 191 expr if ($f1 >= $f2 \, $f2 \, $f1);
#X text 258 191 Only take values <= the upper bound value;
#X text 257 299 Only take values >= the lower bound value;
#X obj 34 112 inlet input_value;
#X obj 241 162 inlet upper_bound;
#X obj 241 271 inlet lower_bound;
#X obj 34 298 expr if ($f1 <= $f2 \, $f2 \, $f1);
#X text 813 55 Bounds the given input value to the specified interval range: [upper bound \, lower bound].;
#X text 806 102 Args: input_value (float) - the value of the particular input (eg \, heart rate) upper_bound (float) - the upper bound to restrict the input value by. If input_value > upper_bound \, returns the upper_bound. lower_bound (float) - the lower bound to restrict the input value by. If input_value < lower_bound \, returns the lower_bound.;
#X text 814 208 Returns: the bounded input value;
#X text 241 247 LOWER BOUND (MIDDLE INLET):;
#X text 241 138 UPPER BOUND (RIGHT INLET):;
#X text 34 88 INPUT VALUE (LEFT INLET):;
#X connect 0 0 4 0;
#X connect 1 0 10 0;
#X connect 2 0 3 0;
#X connect 4 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 4 1;
#X connect 9 0 10 1;
#X connect 10 0 2 0;
#X restore 791 737 pd bound_values;
#X floatatom 791 711 5 0 0 0 - - - 0;
#X floatatom 791 821 5 0 0 0 - - - 0;
#X floatatom 893 711 5 0 0 0 - - - 0;
#X floatatom 842 711 5 0 0 0 - - - 0;
#X obj 842 654 loadbang;
#X obj 791 626 r appAccelerometer;
#X text 773 603 ACCELEROMETER INPUT:;
#X text 840 793 Default start-up volume is 0.75;
#X msg 804 794 0.75;
#X text 940 700 Bound the volume to the range [0 \, 1];
#X msg 893 687 0.99;
#X msg 842 687 0.5;
#X obj 791 1035 line~;
#X msg 791 1010 \$1 20;
#X msg 674 1298 0.99;
#X text 1287 884 Handle continuous toggle of 1 value into the toggle? - Not 100% sure if this issue would ever be possible in the app \, but could handle this problem relatively easily;
#X text 1317 991 This will require very small delay between turning patch off and closing stream (>4 ms) - see if required;
#X text 1410 1127 How to handle 999 values? set to 120 BPM?;
#X text 1348 1161 Add exponential scaling for input values for volume and continuous pitch?;
#X text 1443 1216 Add discrete pitch controls;
#X text 1443 1246 Add discrete pitch controls with portamento;
#X text 389 538 Creates an oscillating cosine wave with default frequency 440Hz, f 24;
#X obj 369 382 hsl 200 50 261.63 1046.52 0 0 empty empty change_pitch -2 -10 0 12 #ffe3c6 #000000 #000000 0 1;
#X floatatom 366 436 5 0 0 0 - - - 0;
#X msg 968 544 300;
#X obj 377 247 loadbang;
#N canvas 0 28 1440 872 bound_values 0;
#X floatatom 34 168 5 0 0 0 - - - 0;
#X floatatom 34 275 5 0 0 0 - - - 0;
#X floatatom 34 322 5 0 0 0 - - - 0;
#X obj 34 345 outlet;
#X obj 34 191 expr if ($f1 >= $f2 \, $f2 \, $f1);
#X text 258 191 Only take values <= the upper bound value;
#X text 257 299 Only take values >= the lower bound value;
#X obj 34 112 inlet input_value;
#X obj 241 162 inlet upper_bound;
#X obj 241 271 inlet lower_bound;
#X obj 34 298 expr if ($f1 <= $f2 \, $f2 \, $f1);
#X text 813 55 Bounds the given input value to the specified interval range: [upper bound \, lower bound].;
#X text 806 102 Args: input_value (float) - the value of the particular input (eg \, heart rate) upper_bound (float) - the upper bound to restrict the input value by. If input_value > upper_bound \, returns the upper_bound. lower_bound (float) - the lower bound to restrict the input value by. If input_value < lower_bound \, returns the lower_bound.;
#X text 814 208 Returns: the bounded input value;
#X text 241 247 LOWER BOUND (MIDDLE INLET):;
#X text 241 138 UPPER BOUND (RIGHT INLET):;
#X text 34 88 INPUT VALUE (LEFT INLET):;
#X connect 0 0 4 0;
#X connect 1 0 10 0;
#X connect 2 0 3 0;
#X connect 4 0 1 0;
#X connect 7 0 0 0;
#X connect 8 0 4 1;
#X connect 9 0 10 1;
#X connect 10 0 2 0;
#X restore 366 213 pd bound_values;
#X floatatom 366 187 5 0 0 0 - - - 0;
#X floatatom 366 297 5 0 0 0 - - - 0;
#X floatatom 468 187 5 0 0 0 - - - 0;
#X floatatom 417 187 5 0 0 0 - - - 0;
#X obj 417 130 loadbang;
#X text 507 182 Bound the frequency values between C4 and C6, f 21;
#X msg 417 163 261.63;
#X msg 468 163 1046.52;
#X text 361 82 GYROMETER INPUT:;
#X obj 366 105 r appGyrometer;
#X text 413 270 Default start-up frequency is 440Hz;
#X msg 377 271 440;
#X text 1446 1278 Do some major cleanup of this patch;
#X connect 0 0 74 0;
#X connect 3 0 2 0;
#X connect 4 0 0 0;
#X connect 8 0 11 0;
#X connect 10 0 15 0;
#X connect 11 0 13 0;
#X connect 12 0 29 0;
#X connect 13 1 14 0;
#X connect 14 0 12 0;
#X connect 15 0 20 0;
#X connect 16 0 17 0;
#X connect 17 0 51 0;
#X connect 20 0 35 0;
#X connect 20 0 37 0;
#X connect 22 0 26 0;
#X connect 23 0 26 0;
#X connect 25 0 15 1;
#X connect 26 0 25 0;
#X connect 27 0 26 0;
#X connect 28 0 34 0;
#X connect 30 0 23 0;
#X connect 34 0 15 0;
#X connect 35 0 42 0;
#X connect 36 0 42 0;
#X connect 37 0 36 0;
#X connect 38 0 1 0;
#X connect 38 0 1 1;
#X connect 39 0 62 0;
#X connect 40 0 39 0;
#X connect 41 0 50 0;
#X connect 42 0 0 1;
#X connect 43 0 44 0;
#X connect 43 0 45 0;
#X connect 43 0 61 0;
#X connect 43 0 46 0;
#X connect 43 0 103 0;
#X connect 44 0 42 2;
#X connect 45 0 42 3;
#X connect 46 0 42 1;
#X connect 47 0 48 0;
#X connect 48 0 3 0;
#X connect 49 0 51 0;
#X connect 50 0 49 0;
#X connect 51 0 8 0;
#X connect 52 0 49 2;
#X connect 53 0 52 0;
#X connect 54 0 49 1;
#X connect 55 0 54 0;
#X connect 58 0 55 0;
#X connect 58 0 53 0;
#X connect 61 0 42 4;
#X connect 62 0 38 1;
#X connect 63 0 71 0;
#X connect 63 0 68 0;
#X connect 63 0 66 0;
#X connect 63 0 67 0;
#X connect 63 0 93 0;
#X connect 64 0 69 0;
#X connect 66 0 62 3;
#X connect 67 0 62 4;
#X connect 68 0 62 2;
#X connect 69 0 10 0;
#X connect 71 0 62 5;
#X connect 74 0 38 0;
#X connect 75 0 76 0;
#X connect 76 0 92 0;
#X connect 77 0 87 0;
#X connect 78 0 80 0;
#X connect 79 0 78 0;
#X connect 80 0 75 0;
#X connect 81 0 78 2;
#X connect 82 0 78 1;
#X connect 83 0 90 0;
#X connect 83 0 89 0;
#X connect 84 0 79 0;
#X connect 87 0 80 0;
#X connect 89 0 81 0;
#X connect 90 0 82 0;
#X connect 91 0 74 1;
#X connect 92 0 91 0;
#X connect 93 0 62 1;
#X connect 101 0 102 0;
#X connect 102 0 4 0;
#X connect 103 0 42 5;
#X connect 104 0 117 0;
#X connect 105 0 107 0;
#X connect 106 0 105 0;
#X connect 107 0 101 0;
#X connect 108 0 105 2;
#X connect 109 0 105 1;
#X connect 110 0 112 0;
#X connect 110 0 113 0;
#X connect 112 0 109 0;
#X connect 113 0 108 0;
#X connect 115 0 106 0;
#X connect 117 0 107 0;
